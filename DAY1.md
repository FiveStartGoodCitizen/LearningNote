
## DAY 1

&nbsp;

​	**二分法** 注意边界问题 查看是否左闭右闭 或者左闭右开  根据开始的left,right设置的开闭原则 ，再根据开闭在for循环里面思考怎么设置边界

双指针

​	记住数组在内存空间中是连续的  单纯的删除并不能移除元素 而是o(n)的时间复杂度 

​	leetcode 27.移除元素中  使用快慢指针 快指针寻找需要删除的元素 慢指针记录索引

-------------------

## DAY 2
&nbsp;

**1.** *Leetcode 977 . 有序数组的平方*

**双指针法**

按非递减顺序排序的整数数组nums，返回每个数字的平方组成的新数组，要求按非递减顺序排序。

```c++
vector<int> sortedSquares(vector<int>& nums)
```

1. return为vector<int>  

2. 暴力方法很容易想到但是时间复杂度为O（n+logn）

3. 思考题目  数组是**有序**的  如果是无序的 这就是中等题

​	考虑最大值在**两端 不在中间**  因此可以考虑是否可以使用双指针

​	本题的难度并不是双指针的用法 而是判断什么时候可以用双指针

4. 总结

​	在排序时，数组是**有序**的，极值在**两端**时，可以考虑双指针。

--------------------------------------------
 

2. ****\*Leetcode 209 .长度最小的子数组\**** ***\*中等\*****

​	给定一个含有 n 个正整数的数组和一个正整数 target 。

​	找出该数组中满足其总和大于等于 target 的长度最小的 子数组

子数组

 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 

 

1.看到数组 一般会考虑到几种常见的解法 双指针(滑动窗口也是双指针的一种) 哈希 排序 分治 动态规划  

一般看上去比较难的题目会优先考虑到动态规划

此题可以使用dp或双指针解 本次使用双指针

2. 这题的难点在于怎么**更新子串**的长度，每次满足子串的大小>=target时，更新子串的长度，并且取**最短**的子串长度。

​	子串长度不难想，快指针往后推，慢指针指向开始的索引，满足条件时，记录下子串的长度。

```c++
subLength = (j - i +1);
```

​	之后思考怎么更新子串的**最短**长度。于此同时 慢指针向后推进查看是否满足条件，满足条件时，更新子串长度。

       ```c++ 
result = result < subLength ? result:subLength;
       ```

3. 在更新子串长度时，需要和比记录的长度大的比较才行，如果开始result=0时，则结果一直为0，所以result取**最大值**。

```c++
 int result = INT32_MAX;
```

4. 总结

​	**画图**思考滑动窗口，或者说指针是怎么移动的。

